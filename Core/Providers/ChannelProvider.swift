import Cocoa
import MagicCore
import NetworkExtension
import OSLog
import SwiftUI
import SystemExtensions

@MainActor
class ChannelProvider: NSObject, ObservableObject, SuperLog, SuperEvent, SuperThread {
    static let shared = ChannelProvider()

    private let data: AppPermissionService = AppPermissionService()

    override private init() {
        super.init()
        os_log("\(Self.onInit)")

        self.emit(.willBoot)
        self.updateFilterStatus(.indeterminate)
        self.setObserver()

        // loadFilterConfiguration ÁÑ∂Âêé filterManager.isEnabled ÊâçËÉΩÂæóÂà∞Ê≠£Á°ÆÁöÑÂÄº
        Task {
            do {
                try await loadFilterConfiguration(reason: "Boot")
            } catch {
                os_log(.error, "\(self.t)Boot -> \(error)")
            }

            let isEnabled = NEFilterManager.shared().isEnabled

            os_log("\(self.t)\(isEnabled ? "‚úÖ ËøáÊª§Âô®Â∑≤ÂêØÁî®" : "‚ö†Ô∏è ËøáÊª§Âô®Êú™ÂêØÁî®")")

            updateFilterStatus(isEnabled ? .running : .disabled)
        }
    }

    nonisolated static let emoji = "üì¢"

    private var ipc = IPCConnection.shared
    private var extensionManager = OSSystemExtensionManager.shared
    private var extensionBundle = AppConfig.extensionBundle

    @Published var error: Error?
    @Published private var _status: FilterStatus = .stopped

    /// ËøáÊª§Âô®Áä∂ÊÄÅÔºàÂè™ËØªÔºâ
    /// Âè™ËÉΩÈÄöËøáupdateFilterStatusÊñπÊ≥ï‰øÆÊîπÁä∂ÊÄÅ
    var status: FilterStatus {
        return _status
    }

    var observer: Any?

    /// Êõ¥Êñ∞ËøáÊª§Âô®Áä∂ÊÄÅ
    /// - Parameter status: Êñ∞ÁöÑËøáÊª§Âô®Áä∂ÊÄÅ
    @MainActor
    private func updateFilterStatus(_ status: FilterStatus) {
        let oldValue = _status

        self._status = status

        os_log("\(self.t)üçã Êõ¥Êñ∞Áä∂ÊÄÅ -> \(status.description) ÂéüÁä∂ÊÄÅ -> \(oldValue.description)")
        if oldValue.isNotRunning() && status.isRunning() {
            registerWithProvider(reason: "not running -> running")
        }

        DispatchQueue.main.async {
            NotificationCenter.default.post(
                name: .FilterStatusChanged,
                object: status,
                userInfo: nil
            )
        }
    }

    func clearError() {
        self.error = nil
    }

    @MainActor
    func setError(_ error: Error) {
        self.error = error
    }

    @MainActor
    func setObserver() {
        os_log("\(self.t)üëÄ Ê∑ªÂä†ÁõëÂê¨")
        observer = nc.addObserver(
            forName: .NEFilterConfigurationDidChange,
            object: NEFilterManager.shared(),
            queue: .main
        ) { _ in
            let enabled = NEFilterManager.shared().isEnabled
            os_log("\(self.t)\(enabled ? "üëÄ ÁõëÂê¨Âà∞ Filter Â∑≤ÊâìÂºÄ " : "üëÄ ÁõëÂê¨Âà∞ Fitler Â∑≤ÂÖ≥Èó≠")")
            Task { @MainActor in
                self.updateFilterStatus(enabled ? .running : .stopped)
            }
        }
    }

    // ËøáÊª§Âô®ÊòØÂê¶Â∑≤ÁªèÂêØÂä®‰∫Ü
    func ifFilterReady() -> Bool {
        os_log("\(self.t)\(Location.did(.IfReady))")

        if NEFilterManager.shared().isEnabled {
//            registerWithProvider()
            self.updateFilterStatus(.running)

            return true
        } else {
            return false
        }
    }

    func viewWillDisappear() {
        guard let changeObserver = observer else {
            return
        }

        nc.removeObserver(
            changeObserver,
            name: .NEFilterConfigurationDidChange,
            object: NEFilterManager.shared()
        )
    }

    func installFilter() {
        os_log("\(self.t)\(Location.did(.InstallFilter))")

        self.clearError()
        self.emit(.willInstall)

        guard let extensionIdentifier = extensionBundle.bundleIdentifier else {
            self.updateFilterStatus(.stopped)
            return
        }

        // Start by activating the system extension
        let activationRequest = OSSystemExtensionRequest.activationRequest(
            forExtensionWithIdentifier: extensionIdentifier,
            queue: .main
        )
        activationRequest.delegate = self
        extensionManager.submitRequest(activationRequest)
    }

    func startFilter(reason: String) async throws {
        os_log("\(self.t)üöÄ ÂºÄÂêØËøáÊª§Âô® üêõ \(reason)  ‚û°Ô∏è Current Status: \(self.status.description)")

        self.emit(.willStart)

        guard let extensionIdentifier = extensionBundle.bundleIdentifier else {
            os_log("\(self.t)extensionBundle.bundleIdentifier ‰∏∫Á©∫")
            self.updateFilterStatus(.stopped)
            return
        }

        // macOS 15Ôºå Á≥ªÁªüËÆæÁΩÆ - ÁΩëÁªú - ËøáÊª§Âô®ÔºåÁî®Êà∑ËÉΩÂà†Èô§ËøáÊª§Âô®ÔºåÊâÄ‰ª•Ë¶ÅÁ°Æ‰øùËøáÊª§Âô®Â∑≤Âä†ËΩΩ

        try await loadFilterConfiguration(reason: reason)

        guard !NEFilterManager.shared().isEnabled else {
            os_log("\(self.t)üëå ËøáÊª§Âô®Â∑≤ÂêØÁî®ÔºåÁõ¥Êé•ÂÖ≥ËÅî")
            registerWithProvider(reason: reason)
            return
        }

        os_log("\(self.t)üöÄ ÂºÄÂßãÊøÄÊ¥ªÁ≥ªÁªüÊâ©Â±ï")

        // Start by activating the system extension
        let activationRequest = OSSystemExtensionRequest.activationRequest(forExtensionWithIdentifier: extensionIdentifier, queue: .main)
        activationRequest.delegate = self
        OSSystemExtensionManager.shared.submitRequest(activationRequest)
    }

    func stopFilter(reason: String) async throws {
        os_log("\(self.t)ü§ö ÂÅúÊ≠¢ËøáÊª§Âô® üêõ \(reason)")

        self.emit(.willStop)

        guard NEFilterManager.shared().isEnabled else {
            self.updateFilterStatus(.stopped)
            return
        }

        try await loadFilterConfiguration(reason: reason)

        NEFilterManager.shared().isEnabled = false
        try await NEFilterManager.shared().saveToPreferences()

        self.updateFilterStatus(.stopped)
    }

    // MARK: Content Filter Configuration Management

    func loadFilterConfiguration(reason: String) async throws {
        os_log("\(self.t)üö© ËØªÂèñËøáÊª§Âô®ÈÖçÁΩÆ üêõ \(reason)")

        // You must call this method at least once before calling saveToPreferencesWithCompletionHandler: for the first time after your app launches.
        try await NEFilterManager.shared().loadFromPreferences()
    }

    func enableFilterConfiguration(reason: String) {
        os_log("\(self.t)ü¶∂ \(Location.did(.EnableFilterConfiguration))")

        self.emit(.configurationChanged)

        guard !NEFilterManager.shared().isEnabled else {
            os_log("\(self.t)FilterManager is Disabled, registerWithProvider")
//            registerWithProvider()
            return
        }

        Task {
            do {
                try await loadFilterConfiguration(reason: reason)

                os_log("\(self.t)üéâ Âä†ËΩΩËøáÊª§Âô®ÈÖçÁΩÆÊàêÂäü")

                if NEFilterManager.shared().providerConfiguration == nil {
                    let providerConfiguration = NEFilterProviderConfiguration()
                    providerConfiguration.filterSockets = true
                    providerConfiguration.filterPackets = false
                    NEFilterManager.shared().providerConfiguration = providerConfiguration
                    if let appName = Bundle.main.infoDictionary?["CFBundleName"] as? String {
                        NEFilterManager.shared().localizedDescription = appName
                    }
                }

                // Â¶ÇÊûútrueÔºåÂä†ËΩΩÂà∞Á≥ªÁªüËÆæÁΩÆ‰∏≠ÂêéÂ∞±ÊòØÂêØÂä®Áä∂ÊÄÅ
                NEFilterManager.shared().isEnabled = true

                // Â∞ÜËøáÊª§Âô®Âä†ËΩΩÂà∞Á≥ªÁªüËÆæÁΩÆ‰∏≠
                os_log("\(self.t)üì∫ Â∞ÜË¶ÅÂºπÂá∫ÊéàÊùÉÂØπËØùÊ°ÜÊù•Âä†ËΩΩÂà∞Á≥ªÁªüËÆæÁΩÆ‰∏≠")
                os_log("\(self.t)ü¶∂ \(Location.did(.SaveToPreferences))")
                NEFilterManager.shared().saveToPreferences { saveError in
                    if let error = saveError {
                        os_log(.error, "\(self.t)ÊéàÊùÉÂØπËØùÊ°ÜÊä•Èîô -> \(error.localizedDescription)")
                        self.updateFilterStatus(.disabled)
                        return
                    } else {
                        os_log("\(self.t)ü¶∂ \(Location.did(.UserApproved))")
                    }

                    self.registerWithProvider(reason: "Â∑≤ÊéàÊùÉ")
                }
            } catch {
                os_log("\(self.t)APP: Âä†ËΩΩËøáÊª§Âô®ÈÖçÁΩÆÂ§±Ë¥•")
                self.updateFilterStatus(.stopped)
            }
        }
    }

    func registerWithProvider(reason: String) {
        os_log("\(self.t)üõ´ registerWithProviderÔºåËÆ© ChannelProvider Âíå Extension ÂÖ≥ËÅîËµ∑Êù•(\(reason)")

        self.emit(.willRegisterWithProvider)

        ipc.register(withExtension: extensionBundle, delegate: self) { success in
            if success {
                os_log("\(self.t)üéâ ChannelProvider Âíå Extension ÂÖ≥ËÅîÊàêÂäü")

                NotificationCenter.default.post(name: .didRegisterWithProvider, object: nil)

                self.updateFilterStatus(.running)
            } else {
                os_log("\(self.t)üíî ChannelProvider Âíå Extension ÂÖ≥ËÅîÂ§±Ë¥•")

                self.updateFilterStatus(.extensionNotReady)
            }
        }
    }
}

// MARK: OSSystemExtensionActivationRequestDelegate

extension ChannelProvider: OSSystemExtensionRequestDelegate {
    nonisolated func request(
        _ request: OSSystemExtensionRequest,
        didFinishWithResult result: OSSystemExtensionRequest.Result
    ) {
        switch result {
        case .completed:
            os_log("\(self.t)üçã OSSystemExtensionRequestDelegate -> completed")
        case .willCompleteAfterReboot:
            os_log("\(self.t)üçã willCompleteAfterReboot")
        @unknown default:
            os_log("\(self.t)\(result.rawValue)")
        }

        DispatchQueue.main.async {
            self.enableFilterConfiguration(reason: "didFinishWithResult")
        }
    }

    nonisolated func request(_ request: OSSystemExtensionRequest, didFailWithError error: Error) {
        os_log(.error, "\(self.t)didFailWithError -> \(error.localizedDescription)")
        DispatchQueue.main.async {
            self.setError(error)
            self.updateFilterStatus(.error(error))
        }
        self.emit(.didFailWithError, userInfo: ["error": error])
    }

    nonisolated func requestNeedsUserApproval(_ request: OSSystemExtensionRequest) {
        os_log("\(self.t)ü¶∂ \(Location.did(.RequestNeedsUserApproval))")
        DispatchQueue.main.async {
            self.updateFilterStatus(.needApproval)
        }
    }

    nonisolated func request(
        _ request: OSSystemExtensionRequest,
        actionForReplacingExtension existing: OSSystemExtensionProperties,
        withExtension extension: OSSystemExtensionProperties
    ) -> OSSystemExtensionRequest.ReplacementAction {
        os_log("\(self.t)actionForReplacingExtension")

        return .replace
    }
}

// MARK: AppCommunication

extension ChannelProvider: AppCommunication {
    nonisolated func extensionLog(_ words: String) {
        let verbose = false

        if verbose {
            os_log("\(self.t)üí¨ Extension said -> \(words)")
        }
    }

    nonisolated func needApproval() {
        NotificationCenter.default.post(
            name: .NeedApproval,
            object: nil,
            userInfo: nil
        )
    }

    /// ÊèêÁ§∫Áî®Êà∑ÊòØÂê¶ÂÖÅËÆ∏ÁΩëÁªúËøûÊé•
    /// - Parameters:
    ///   - id: Â∫îÁî®Ê†áËØÜÁ¨¶
    ///   - hostname: ‰∏ªÊú∫Âêç
    ///   - port: Á´ØÂè£Âè∑
    ///   - direction: ÁΩëÁªúÊµÅÈáèÊñπÂêë
    ///   - responseHandler: ÂìçÂ∫îÂ§ÑÁêÜÂõûË∞É
    nonisolated func promptUser(id: String, hostname: String, port: String, direction: NETrafficDirection, responseHandler: @escaping (Bool) -> Void) {
        let verbose = false

        let shouldAllow = AppPermissionService().shouldAllow(id)
        if shouldAllow {
            if verbose {
                os_log("\(self.t)‚úÖ Channel.promptUser üë§ with App -> \(id) -> Allow")
            }
            responseHandler(true)

            DispatchQueue.main.sync {
                NotificationCenter.default.post(name: .NetWorkFilterFlow, object: FlowWrapper(
                    id: id,
                    hostname: hostname,
                    port: port,
                    allowed: true,
                    direction: direction
                ))
            }
        } else {
            if verbose {
                os_log("\(self.t)üà≤ Channel.promptUser üë§ with App -> \(id) -> Deny")
            }
            DispatchQueue.main.sync {
                NotificationCenter.default.post(name: .NetWorkFilterFlow, object: FlowWrapper(
                    id: id,
                    hostname: hostname,
                    port: port,
                    allowed: false,
                    direction: direction
                ))
            }
            responseHandler(false)
        }
    }
}

#Preview("APP") {
    RootView(content: {
        ContentView()
    })
    .frame(width: 700)
    .frame(height: 600)
}
